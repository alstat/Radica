{
    "collab_server" : "",
    "contents" : "#' Dose-Effect Curve\n#' @export\n#' \n#' @description\n#' Generates calibration curve for the chromosomal aberration.\n#' \n#' @param x output from fit.coef function;\n#' @param level confidence level for fitted values generated;\n#' @param xaxis x-axis tick labels;\n#' @param newdat supply newdata\n#' @param yci default \\code{null}; length 2 numeric value of Y_L and Y_U.\n#' @param eta precision for Y_L and Y_U intersecting C_U and C_L, respectively.\ndose_curve <- function (x, level = 0.95, xaxis = NULL, newdat = NULL, yci = NULL, eta = .0001, ...) {\n  doses <- x$preliminary[, 1]; cells <- x$preliminary[, 2]; aberrations <- x$preliminary[, 3]\n  fit <- x$fitted_values$fit; mod_est <- x$summary$coefficients; mod_cor <- x$summary$correlation\n  est_se <- mod_est[, 2]; vcov_mat <- mod_cor * outer(est_se, est_se)\n  if (nrow(mod_est) == 3)\n    R <- qchisq(level, df = 3)\n  if (nrow(mod_est) == 2)\n    R <- qchisq(level, df = 2)\n  \n  scales <- list()\n  if (!is.null(xaxis) && is.numeric(xaxis)) {\n    scales <- list(\n     x = list(\n        at = xaxis,\n        labels = xaxis\n        )\n     ) \n  }\n  \n  xyplot(aberrations / cells ~ doses, xlab = \"Doses\", \n         ylab = \"Aberration per cell\", cex = 1.5, pch = 19, col = \"#0080ff\",\n         key = list(\n           corner = c(.02, .98),\n           rectangles = list(col = c(\"#0080ff\", \"#ff00ff\", \"darkgreen\"), size = 4.5, height = 0.8),\n           text = list(c(\"Data\", \"Fitted\", paste(level * 100, \"% C.I.\", sep ='')))),\n         scales = scales,\n         panel = function (x, y, ...) {\n           if (is.null(xaxis)) {\n             panel.grid(h = -1, v = -1, col.line = \"cornsilk2\")\n           } else if (!is.null(xaxis) && is.numeric(xaxis)) {\n             panel.grid(h = -1, v = 0, col.line = \"cornsilk2\")\n             panel.abline(v = xaxis, col = \"cornsilk2\")\n           }\n           \n           if (is.null(newdat)) {\n             panel.xyplot(x, y, ...) \n           } else if (!is.null(newdat)) {\n             if (is.null(yci)) stop('Supply the Y_U and Y_L, see Crow et. al (1959)')\n             if (nrow(mod_est) == 3) {\n               dfunc <- function(y, a = mod_est[2, 1], b = mod_est[3, 1], c = mod_est[1, 1]) {\n                 abs((-a + sqrt((a ^ 2) + (4 * b) * (y - c))) / (2 * b))\n               }\n               \n               fit_df <- matrix(NA, 6000, 3)\n               for (i in seq(0, 6, by = 0.001)) {\n                 yy <- mod_est[1, 1] + mod_est[2, 1] * i + mod_est[3, 1] * (i ^ 2)\n                 y_u <- mod_est[1, 1] + mod_est[2, 1] * i + mod_est[3, 1] * (i ^ 2) + sqrt(R) * \n                   sqrt(vcov_mat[1, 1] + vcov_mat[2, 2] * (i ^ 2) + vcov_mat[3, 3] * (i ^ 4) +\n                          2 * vcov_mat[1, 2] * i + 2 * vcov_mat[1, 3] * (i ^ 2) + 2 * vcov_mat[2, 3] * (i ^ 3))\n                 y_l <- mod_est[1, 1] + mod_est[2, 1] * i + mod_est[3, 1] * (i ^ 2) - sqrt(R) * \n                   sqrt(vcov_mat[1, 1] + vcov_mat[2, 2] * (i ^ 2) + vcov_mat[3, 3] * (i ^ 4) +\n                          2 * vcov_mat[1,2] * i + 2 * vcov_mat[1,3] * (i ^ 2) + 2 * vcov_mat[2, 3] * (i ^ 3))\n                 \n                 fit_df[i * 1000, ] <- c(y_l, yy, y_u)\n               }\n             } else if (nrow(mod_est) == 2) {\n               dfunc <- function (y, a = mod_est[2, 1], c = mod_est[1, 1]) {\n                 (y - c) / a\n               }\n               \n               fit_df <- matrix(NA, 6000, 3)\n               for (i in seq(0, 6, by = 0.001)) {\n                 yy <- mod_est[1, 1] + mod_est[2, 1] * i\n                 y_u <- mod_est[1, 1] + mod_est[2, 1] * i + sqrt(R) * \n                   sqrt(vcov_mat[1, 1] + vcov_mat[2, 2] * (i ^ 2) + 2 * vcov_mat[1, 2] * i)\n                 y_l <- mod_est[1, 1] + mod_est[2, 1] * i - sqrt(R) * \n                   sqrt(vcov_mat[1, 1] + vcov_mat[2, 2] * (i ^ 2) + 2 * vcov_mat[1, 2] * i)\n                 \n                 fit_df[i * 1000, ] <- c(y_l, yy, y_u)\n               }\n             }\n             \n             \n             cil <- fit_df[, 3] - yci[1]\n             cil_indx <- which((cil > 0) & (cil < eta))\n             cil <- cil[(cil > 0) & (cil < eta)][1]\n             \n             ciu <- fit_df[, 1] - yci[2]\n             ciu_indx <- which((ciu > 0) & (ciu < eta))\n             ciu <- ciu[(ciu > 0) & (ciu < eta)][1]\n             \n             dose_est <- dfunc(newdat[,3] / newdat[,2])\n             panel.xyplot(dose_est, newdat[,3] / newdat[,2], ...)\n             panel.arrows(dose_est, newdat[,3] / newdat[,2], dose_est, 0, length = 0.15, col = \"#0080ff\")\n             panel.abline(v = newdat[,1], col = \"red\")\n             panel.segments(0, yci[1], cil_indx * .001, yci[1], col = \"gray\", lty = \"dashed\", lwd = 2)\n             panel.segments(cil_indx * .001, yci[1], cil_indx * .001, 0, col = \"gray\", lty = \"dashed\", lwd = 2)\n             \n             panel.segments(0, yci[2], ciu_indx * .001, yci[2], col = \"gray\", lty = \"dashed\", lwd = 2)\n             panel.segments(ciu_indx * .001, yci[2], ciu_indx * .001, 0, col = \"gray\", lty = \"dashed\", lwd = 2)\n           }\n           \n           if (nrow(mod_est) == 3) {\n             panel.curve(expr = mod_est[1, 1] + mod_est[2, 1] * x + mod_est[3, 1] * (x ^ 2), from = 0, to = max(doses), lwd = 2, col = \"#ff00ff\")\n             panel.curve(expr = mod_est[1, 1] + mod_est[2, 1] * x + mod_est[3, 1] * (x ^ 2) + sqrt(R) * \n                           sqrt(vcov_mat[1, 1] + vcov_mat[2, 2] * (x ^ 2) + vcov_mat[3, 3] * (x ^ 4) +\n                                  2 * vcov_mat[1, 2] * x + 2 * vcov_mat[1, 3] * (x ^ 2) + 2 * vcov_mat[2, 3] * (x ^ 3)), from = 0, to = max(doses), lwd = 2, col = \"darkgreen\")\n             panel.curve(expr = mod_est[1, 1] + mod_est[2, 1] * x + mod_est[3, 1] * (x ^ 2) - sqrt(R) * \n                           sqrt(vcov_mat[1, 1] + vcov_mat[2, 2] * (x ^ 2) + vcov_mat[3, 3] * (x ^ 4) +\n                                  2 * vcov_mat[1,2] * x + 2 * vcov_mat[1,3] * (x ^ 2) + 2 * vcov_mat[2, 3] * (x ^ 3)), from = 0, to = max(doses), lwd = 2, col = \"darkgreen\") \n           } else if (nrow(mod_est) == 2) {\n             panel.curve(expr = mod_est[1, 1] + mod_est[2, 1] * x, from = 0, to = max(doses), lwd = 2, col = \"#ff00ff\")\n             panel.curve(expr = mod_est[1, 1] + mod_est[2, 1] * x + sqrt(R) * \n                           sqrt(vcov_mat[1, 1] + vcov_mat[2, 2] * (x ^ 2) + 2 * vcov_mat[1, 2] * x), from = 0, to = max(doses), lwd = 2, col = \"darkgreen\")\n             panel.curve(expr = mod_est[1, 1] + mod_est[2, 1] * x - sqrt(R) * \n                           sqrt(vcov_mat[1, 1] + vcov_mat[2, 2] * (x ^ 2) + 2 * vcov_mat[1, 2] * x), from = 0, to = max(doses), lwd = 2, col = \"darkgreen\")\n           }\n         }, ...)\n}",
    "created" : 1425783287783.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2642474567",
    "id" : "EACBC67A",
    "lastKnownWriteTime" : 1457139822,
    "last_content_update" : 0,
    "path" : "~/Documents/R Files/Radica/R/dose_curve.R",
    "project_path" : "R/dose_curve.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}